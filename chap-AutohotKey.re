= AutoHotkey

== AutoHotkeyとは

AutoHotkeyは、ショートカットキーを自分で作成するなど、キーボードをカスタマイズできるスクリプトエンジンです（最新Ver1.1.14.03 - 2014/02/14）。トリガーとなるキーの組み合わせや単打、トリガーした後の処理を簡単な文法で設定できます。キーボードのキーの入力を別のキーに変更するだけでなく、文字列操作やファイル操作、マウス操作、GUIプログラムの作成、特定ウィンドウでのみ動作、タイマーなど多彩なコマンドが用意されています。今回の本では、簡単に設定できるトリガーのキーの組み合わせでキー入力、マウス操作を行う方法を紹介します。文字列操作やファイル操作、GUI作成は日本語がいいならAutoHotKey Wiki、英語でもいいならAutoHotKey helpを参照してください。すべてのトリガー、処理が掲載されています。

== 実際にキーバインド設定してみよう

今回のゴールは、自作キーボードのようにあるキーを押していると他のキーの動作が変わるという処理を実装します。あるキーを押しながら他のキーを押して上下左右カーソル移動、Deleteキー、Enterキー、IME切り替えキー、マウス移動ができるようにしていきます。
まずはじめに、AutoHotKeyをインストールしましょう。公式サイト（https://autohotkey.com/download/）のDownload Autohotkey Installerをクリックしてインストーラをダウンロードします。インストーラを起動して、特にこだわりがなければ「Express Installation」をクリックしてください。「View the Tutorial」は英語ですが、読めるならやってみてください。（筆者はやっていません……）

次にスクリプトを書いていきます。エディタを開くか、テキストファイルを作成して、以下を書きます。

//emlist[ex1.txt]{
a::b
Return
//}

これを保存し、拡張子を.ahkに変更します。すると、緑背景にHが描かれたアイコンに変更され、ダブルクリックで実行できます。何も起こっていないように思えますが、Windows画面右下のインジケーターにAutoHotKeyのアイコンが表示されています。つまり、バックグラウンドで実行されています。テキストファイルで「a」キーを入力してみてください。「b」が入力されます。複数行の場合上から順番に実行していきますが、Returnで処理を終了します。この例は、「a」キーを「b」に変換するというものです。インジケーターからAutoHotKeyのアイコンのex1.ahkを右クリックしてExitをクリックするとこのスクリプトが終了します。スクリプトが動作しているときのみ操作されるので、テキストファイルで「a」キーを入力すると「a」が入力されます。

これで単打のキー入力変更ができました。複数キー組み合わせの時はどうするのでしょうか。ex1.ahkを右クリックして、「Edit This Script」をクリックすると、編集できます。次のように変更します。変更を反映するには右クリックメニューのReload This Scriptをクリックするか、もう一度ファイルをダブルクリックして次の画面でOKを押します。

//emlist[ex1.txt]{
+a::b
Return
//}

「a」キーを押すと「a」が入力されます。+とは何なのでしょうか。これは、Shiftキーです。Shiftキーとaキーの同時押しでbが入力されます。AutoHotKeyでは、修飾キーを記号で表します。修飾キーとは単独では文字入力や制御など具体的な機能を持たないですが、 他のキーとの組み合わせた時に何らかの機能を発揮させることができるキーのことです。 英語ではモディファイアキー、モディファイアと呼ばれます。
//emlist[修飾キー]{
^	Ctrlキー
!	Altキー
+	Shiftキー
#	Winキー
//}

しかしこれでは、修飾キーとの同時押ししか定義できません（例：aとbの同時押しが定義できない）。また、可読性が低いです。そこで、Send関数を使います。

Send関数は、キーストロークやマウスクリックを発生させる関数です。上記の内容も、AutoHotKey処理内部ではSend関数に変更されています。今回は特定のキーの組み合わせで特定のキーを送信する設定をします。
//emlist[特定キー送信]{
a & b::Send, ^a
Return
//}

とすると、「a」と「b」の同時押しで「Ctrl+c」が入力されるようになります。それを確認した後、「a」を押してみてください。「a」が無効化されているのではないでしょうか。このように、Send関数で最初に設定したキーが無効化されることがありますので、無効化されても問題ないキーを使いましょう（そんなキーがないという人は後述するChangeKeyを使いましょう。）。Send関数では、文字列も送信できますし、連打も定義できます（｛押すキー、回数｝）。大文字小文字は区別されます。ここまでできれば、キー操作のショートカットキーは実現できます。(「よろしくお願いいたします。」「お世話になっております。」を一回のキー操作で入力することも可能）

ここで、無変換キーをトリガーにして、同時押しでカーソルキーが入力されるようにします。キーの指定ですが、今までのようにそのキーを指定すればよかったのですが、AutoHotKeyはUS配列基準です。US配列には、無変換キーと変換キー、カタカナひらがなキーは存在しません。よって、キーコードで指定します。キーコードの確認方法は、インジケーターのahkファイルを右クリック→Openをクリックします。開いた画面のView→Key history and script infoをクリックし、キーコードを確認したいキーを押した後、F5を押すと、押したキーの履歴が表示されます。

//image[keycodecheck][キーコード確認][scale=0.3]

SCの行の値でもキーを指定することができます。たとえば、「a」は「sc02A」になります。US配列に存在しない無変換キー、変換キー、カタカナひらがなキーはキーコードを確認してください。ちなみに、Typeの行では入力された文字、Up/Dnの行はdがキーを押した/uがキーを離したか、Elapsedがひとつ前との経過時間、Keyがスクリプトの処理が反映されて入力された文字、Windowがどのウィンドウ上の操作だったかです。
では、変換キーとjで←を入力してみましょう。

//emlist[変換キーを使う]{
sc079 & j::Send, {Blind}{left}
Return
//}

どうですか？動作しましたか？動作しなかった方もいると思います。これは、ドライバによっては無変換キー、変換キー、カタカナひらがなキーのキーコードをうまくAutoHotKeyが認識できないことがあるからです（Keyがnot found）。動作しなかった方、Send関数で最初に書いたキーが無効化されてしまった方は、ChangeKeyというソフトを利用します。（動作した方もキー単押しはChangeKeyはGUIで簡単に設定できるので読むといいかも。）

== うまくいかないキーボードはChangeKeyを使おう

ChangeKeyは、常駐せずにキー割り当てを変更できるフリーソフトです。Windowsの機能として、レジストリを書き換えることでキー割り当てを変更することができます。レジストリ書き換えを失敗するとPCのシステムを破壊することがあるので、このソフトでレジストリ書き換えを代行してもらうと安全だと思います。
まずはじめに。窓の杜からChangeKeyをダウンロードします。（https://forest.watch.impress.co.jp/library/software/changekey/）
圧縮形式がLZHなので、解凍ソフトを別にインストールしておいてください。解凍すると、そのフォルダにChgKey.exeがあります。右クリック→管理者として実行をクリックしてください。

変更したいキーをクリックして、クリック後の画面で設定したいキーをクリックします。この例では、CapsLockをCtrlに変更しています。登録→現在の設定内容で登録しますをクリックして、PCを再起動するとキーが変更されています。戻したい場合は、またこのソフトで変更してください。

//image[ChangeKeyRaw][変更前][scale=0.3]

//image[ChgKeyCaps][変更後][scale=0.3]

さて、変換キーがうまく動作しなかった場合、AutoHotKeyが認識できるキーに変更すればいいと考えられます。普段使わず、操作が邪魔にならず認識できるキーにしたいですね。そんなキーがキーボードに存在しています。それは、ScrollLock、Pause/Breakです。今回は、ScrollLockを使用します。 他の方法としては、キーボードにはないがPCには設定されている仮想キーコードとしてF13～F24キーが存在しています。これを用いる方法もあります。キーコードは前節での内容を参考に調べてください。変更後のキーを選択する画面で、Scan codeをクリックして調べたキーコードを設定するとそのキーに設定されます。

=== [column]ScrollLock、Pause/Break

ScrollLock、Pause/Breakの機能を知っていますか？Excelなどの表計算ソフトでカーソルキーを押すと選択セルが動きますがScrollLockをONにすると選択セル位置は固定のままスクロールバーが動きます。Excelの動きがおかしくなった、というの原因のひとつにこれがあります。Pause/Breakキーは、処理を途中で止めるものです。コマンドプロンプトで処理停止に使えます（ctrl+cと同じ処理）。使う場面はほとんどないキーですが、キーボードに残っています。
===

AutoHotKeyでScrollLockを使ってキーバインド設定し、ChangeKeyで変換キーをScrollLockに割り当てするとよさそうです。すべてのカーソルキーを実装しましょう。（sc079で動作した方はScrollLockはsc079でも可）ScrollLockはキー名で使えます。

//emlist[カーソル移動]{
ScrollLock & j::Send, {Blind}{left}     ;←
ScrollLock & i::Send, {Blind}{up}       ;↑
ScrollLock & k::Send, {Blind}{down}     ;↓
ScrollLock & l::Send, {Blind}{right}    ;→
//}

筆者はゲームでWASD移動に慣れているため、右手も同じ形にしました。横一列のほうが慣れているなら、HJKLに設定すると良いですね。これでカーソルキーのキーバインド設定ができました。他のキーを使ってもやってみましょう。他のキーの組み合わせでもやってみよう、となったとき、気を付けることがあります。キーコードの指定は特殊キーに当たるものはキー名を｛｝で囲む必要があります。既に意味を持っている記号や単語を区別するためです。^！+#｛｝は囲む必要がある記号です。すでに意味を持ってますよね。

== 便利なキーバインド設定の例

筆者が使っているキーバインド設定を紹介します。 ChangeKeyでの設定は@<img>{ChangeKeyafter}に示します。

//image[ChangeKeyafter][変更後][scale=0.3]

AutoHotKeyではマウス操作、単語移動、遠いキーを近くに設定しています。まず、マウス操作を設定しましょう。マウスのクリックはMouseClickで実現できます。

//emlist[マウスクリック]{
ScrollLock & w::MouseClick,left       ;左クリック
ScrollLock & r::MouseClick,right      ;右クリック
//}
leftが左、rightが右クリックです。leftのほかにも条件を記述できます。MouseClickの記述法は、
//emlist[mouseclick]{
MouseClick [, WhichButton, X, Y, ClickCount, Speed, D|U, R]

 * WhichButton(left,right,middle,wheelup,wheeldown)
 * X,Yはクリックする座標。ディスプレイ左上の座標が（0，0）で、マウスカーソルも移動する（省略時は現在位置）
 * ClickCountはクリックする回数（省略時は1回）
 * Speedは座標指定時に移動する速度。0～100を設定（0が即時）（マウス移動が速すぎると不都合が発生するソフトが存在）
 * D|UはDが押しっぱなし、Uが押下を離す、省略時はクリック
 * Rは座標指定がカーソル位置からの相対座標になる

//}

例では、WhichButton以降すべて省略していますが、他にも記述する場合は、指定したい値が記述法での位置に合うように,を足してください。,,と複数並ぶこともあります。マウスの移動は、MouseCMoveを使います。
//emlist[マウス移動]{
ScrollLock & s:: MouseMove, -11,0,0,R   ;左
ScrollLock & f:: MouseMove, 11,0,0,R    ;右
ScrollLock & e:: MouseMove, 0,-11,0,R   ;上
ScrollLock & d:: MouseMove, 0,11,0,R    ;下
//}
というように書きます。

MouseMoveの記述法は、
//emlist[Mousemove]{
MouseMove, [X,Y, Speed, R]

 * X, Yは移動先の座標。ディスプレイ左上の座標が（0，0）
 * Speedは座標指定時に移動する速度。0～100を設定（0が即時）
 * Rは座標指定がカーソル位置からの相対座標になる

//}
Rを書いていない場合はその座標に移動します。Rを書くと今の座標から指定した座標だけ移動します。細かい移動で設定していると大きく移動するときに不便なので、大きく移動する場合も設定すると便利です。


//emlist[大きなマウス移動]{
ScrollLock & z:: MouseMove, -400,0,5,R
ScrollLock & v:: MouseMove, 400,0,5,R
ScrollLock & c:: MouseMove, 0,-400,5,R
ScrollLock & x:: MouseMove, 0,400,5,R
//}

単語移動を設定できます。
//emlist[単語移動]{
ScrollLock & o::Send, {Blind}^{right}
ScrollLock & u::Send, {Blind}^{left}
//}

エンターキーまで小指を伸ばすのがつらく、親指で押しやすいキーはすべて使っているので同時押しにEnterキーを割り当てました。
//emlist[エンターキー]{
ScrollLock & Space::Send, {Blind}{Enter}
//}

「、」の2連打で「。」が入力できたら楽だと思い、実装しています。
//emlist[2連打設定（長押しでも反応）]{
sc033::
If (A_PriorHotKey == A_ThisHotKey and A_TimeSincePriorHotkey < 200)
  {
    Send,{BS}
    Send,{sc034}
  }
else{
    Send,{sc033}
}
Return
//}
A_PriorHotKeyは一回前に押したキー、A_ThisHotKeyは今押したキーなので同じキーだと連打しているとわかります。TimeSincePriorHotkeyはこの2つのキーの差です。連打が200ミリ秒以下だったら、入力された「、」を消して、「。」を入力し、そうでなければそのまま「、」を入力するというものです。連打を感知する間隔は変更できます。この設定だと、連打でなく長押しにも反応します。別の設定方法だと、

//emlist[ahkwiki]{
sc033::
   Keywait, sc033, U ;1回目のキーが押し上げられるのを待つ
   Keywait, sc033, D T0.2 ;0.2秒待つ。この間に「、」が押されればErrorLevelに0，そうでないなら1が代入
   If (ErrorLevel=1) ;直前のコマンド＝Keywaitがタイムアウトで失敗＝1なら
      {
        Send,{sc033}
      }
   else
      {
        Send,{BS}
        Send,{sc034}
      }
   return
//}

Keywaitを使って、押下と離す状態を感知して、2回目が押されたら入力された「、」を消して、「。」を入力しています。連打を感知する間隔は変更できます。こちらの設定方法だと、長押しには反応しません。

もちろん、キー入力だけではなくアプリケーションの起動も設定できます。Esc2連打でエディタ起動、Alt2連打でAlt-F4も設定しています。

== 終わりに
この章を読むことによって、ChangeKeyによるキー割り当て変更、AutoHotKeyによるキー割り当て変更、キーバインド設定、マウス操作が可能になりました。筆者が行っている設定を紹介しましたが、使用しているキーボードは変換キーがちょうど親指の位置に来るスペースキーが小さいタイプなのでこのような設定になっています。使っているキーボードだけでなく使用者の好み・タイピング方法によって使いやすい設定は異なるので、ぜひ自分にあった設定をみつけてください。他にもAutoHotKeyでは普通に押した場合と長押しで処理を変えたり、タイマー設定、ループもできるので調べればいろいろなことができます。ぜひ、自分好みの設定に挑戦しましょう。（AutoHotKey wiki:http://ahkwiki.net)